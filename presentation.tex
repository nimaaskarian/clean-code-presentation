\documentclass{beamer}
\usepackage{listings}
\usepackage{qrcode}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}
\setbeameroption{show notes on second screen=right}
% \addtobeamertemplate{note page}{}{\thispdfpagelabel{notes:\insertframenumber}}
\setbeamertemplate{note page}{\pagecolor{yellow!5}\vfill\insertnote\vfill}
\usepackage[shorthands=off,bidi=default]{babel}
\babelfont[persian]{rm}[Renderer=HarfBuzz]{Vazirmatn}
\babelfont[persian]{sf}[Renderer=HarfBuzz]{Vazirmatn}
\makeatletter 
\def\beamer@framenotesbegin{% at beginning of slide
     \usebeamercolor[fg]{normal text}
      \gdef\beamer@noteitems{}% 
      \gdef\beamer@notes{}% 
}
\makeatother

\title{Clean Code}
\subtitle{and its necessity in software development}
\author{Nima Askarian}
\date{}

\definecolor{codegreen}{rgb}{0.1,0.5,0.1}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}

% Set up the style for the lstlisting environment
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\fontspec{JetBrains Mono Regular}\scriptsize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
literate={*}{{\scalebox{0.8}{*}}}1
}

% Apply the style to the lstlisting environment globally
\lstset{style=mystyle}

\begin{document}
\begin{frame}
\maketitle
\end{frame}

\section{Roadmap}
\begin{frame}
\frametitle{Roadmap}
\tableofcontents
\end{frame}

\section{Code}
\subsection{What is code?}
\begin{frame}
\note[item]{
  details = \foreignlanguage{persian}{جزییات}
}
\note[item]{
  Coding is the translation of the program you already designed and know the algorithms of, to a detailed solution that is understandable by machine. 
}
\note[item]{
  difference between code of two languages
}
\note[item]{
  difference between code of two people
}
\note[item]{
  This latex document
}
\note[item]{
  Bash scripting
}
\note[item]{
  Matlab
}
\note[item]{
  R language
}
\frametitle{What is code?}
  Code is the details of a solution, that machines understands. \\
\end{frame}

\begin{frame}
\frametitle{There will be code}
Who code any more? Right?
  \includegraphics[width=\textwidth]{~/copilot.jpg}
\note[item]{
Some of you might say: A presentation about code is behind the times.
As we all know, we have ChatGPT, Github Copilot, and more generative AI models. We can just ask them to generate the code for us! \\
}
\note[item]{
  \textbf{NONSENSE!} We will never be rid of code.
As in high level languages, most of the details are generated by computer.
But low level languages are still learned and used as they offer a lot of control.
}
\note[item]{
Just like the high level languages, we can write a "prompt" for the generative AI model, 
}
\note[item]{
  but at some level, details can't be abstracted or ignored. 
}
\note[item]{
So we have to add those details into our "prompt"
}
\note[item]{
  If the bot doesn't understand those details, we would crawl into the code to find out whats wrong and what should we add
}
\note[item]{
  When working with companies, that company or project has its own code design. \\
  EVEN OPEN SOURCE
}
\note[item]{
  Where we can use this bots
}


\end{frame}

\begin{frame}
\frametitle{The only valid measurement of code quality: WTFs/minute}
\note[item]{
  https://www.osnews.com/story/19266/wtfsm/
}
\begin{columns}
  \column{0.5\textwidth} 
  \includegraphics[height=1\textwidth]{~/wtfm.jpg}
  \column{0.5\textwidth}
  As you can see on the left side, \textbf{good code} is what you expect it to be. 
  You see less people wonder about what you have wrote when you have good code.\\
  \textbf{Bad code} however, creates confusion, and reads bad. 
  You often wander around in your own bad code for hours, trying to get a clue of what did you meant.
\end{columns}
\end{frame}

\subsection{Bad code}
\begin{frame}
  \frametitle{Bad code}
  \note[item]{We all KNOW what bad code does to a project.}

  \begin{quote}
  I know of one company that, in the late 80s, wrote a killer app.
  It was very popular, and lots of professionals bought and used it.
  But the release cycle began to stretch.
  Bugs were not repaired from one release to the next.
  Load times grew and crashes increased.
  I remember the day I shut the product down in frustration and never used it again.
  The company went out of business a short time after that. \\

  - Robert C. Martin
  \end{quote}

  \note[item]{
    deadlines and bad code
  }

  \note[item]
  {
  How many times \textbf{you} have faced the same problem that the team faced in their development?
  If you had worked with code for a couple of years, probably a lot.
  }
\note{}
\end{frame}


\begin{frame}
  \frametitle{The broken window theory}
  A building that have broken windows, looks like nobody cares about it.
  So people stop caring. They allow more windows to become broken.
  \note[item]{
    Wikipedia, broken window theory page
  }
  \note[item]{
    Social scientists has introduced this
  }
  \note[item]{
    Was popularized by a police commissioner in New York city
  }
  \note[item]{
    Thats why bad code "rots" over time.
    If someone have some bad code written in a module,
    chances are that module will become a mess over time.
  }

  \note[item]{
    rot =  \foreignlanguage{persian}{فاسد شدن}
  }

\end{frame}

\subsection{Clean Code}
\begin{frame}{Clean Code}
  \note[item]{
    The definition of clean code varys a lot in the software engineering world.
    Most of the people opinions persist on these things:
  }

  \note[item]{
    Can be enhanced by another developers
    \begin{itemize}
      \item Meaningful names
      \item Functions
      \item Simplicity
    \end{itemize}
  }
  \note[item]{
   Good tests
  }
  \begin{itemize}
    \item Is what you expect it to be
    \item Reads well
    \item Can be enhanced by another developers
    \item Tests
  \end{itemize}
\note{}
\end{frame}
\section{How to write clean code}
\subsection{Writing meaningful names}
\begin{frame}

  \frametitle{Use}
  \note[item]{
    Names with meaningful distinctions \\ 
    For example, calling two list of numbers \textit{A} and \textit{B}, \textit{A1} and \textit{A2} are completely opposite of what you should do.\\
  }
  \note[item]{
    copying two strings, src, dest
  }
  \begin{itemize}
    \item Intention revealing names
    \item Names with meaningful distinctions
    \item Pronounceable names
    \item Searchable names
    % \item When something have multiple names, just use one of them inside one project. For \textit{example}, \textit{fetch}, \textit{retrieve} and get are the same name.
  \end{itemize}

\note{}
\end{frame}
\begin{frame}
  \frametitle{Avoid}
  \note{ 
    \begin{itemize}
      \item like \textit{a}, \textit{b}.\\
    x and y for a vector, or i and j as iteration variables are acceptable
      \item like \textit{list}, \textit{number}, \textit{ints}.
      \item  Sometimes you leave false clues that obscure the meaning of code.
      \item (like \textit{ymdhms} for year, month, day, hour, minute and second)
      \item keeping things in mind that only mean something in your own mind
      \item like jokes. using \textit{HolyHandGrenade} instead of \textit{DeleteItems}. \\
      \textit{SaulGoodMan} instead of the class \textit{Lawyer}
      \item append and insert
      \item like get, fetch retrieve
    \end{itemize}
  }
  \note{
    Each identifier, should define what its purpose is, without extra clutter. 
  }
  \begin{itemize}
    \item One character only, without proper context.
    \item Vauge names.
    \item Disinfomation.
    \item Single character abberivations
    \item Mental mapping
    \item Clever names \\
    \item Don't use the same word for two different concepts
    \item Don't use different names for same concept
  \end{itemize}
\note{}
\end{frame}
\begin{frame}
  \frametitle{Class and method names}
  \textbf{Class names} should be noun, or noun phrase names like \textit{Customer}, \textit{Account} \textit{Account}.\\
  \note[item]{
    Avoid names like \textit{Manager} or \textit{Data} inside the name of a class. 
  }
  \textbf{Method names} should be verb or verb phrase.
  \note[item]{
    like \textit{copyString}, \textit{deletePage} or \textit{save}.
  }
\end{frame}

\begin{frame}{Use solution domain names}
  Using the names from progamming well known names.
  \note[item]{
    instead of add, use insert or append.
  }
  \note[item]{
    instead of a random character for iteration variable, use i, j, k.
  }
  \note[item]{
    also don't use the well known names in a misleading way
  }
\end{frame}

\begin{frame}{Use problem domain names}
  Using the names from real world that we are implementing, are well known and give proper context.
  \note[item]{
    You have a series managing app called \textit{BingeWatcher}.
    Using \textit{Binge} for the name of \textit{Series} class is also a bad idea.
  }
\end{frame}

\begin{frame}
  \frametitle{Add proper context}
  Proper context can make code read very better.
  This is usually done with breaking down the code into smaller functions.
\end{frame}

\begin{frame}
  \frametitle{Avoid clutter}
  \note[item]{
    clutter = \foreignlanguage{persian}{آت و آشغال}
  }
  Avoid extra context that we call "clutter"
  \note[item]{
    Prefixing all the classes with \textit{BW} would be a bad idea.
  }
\end{frame}
\subsection{example}
\begin{frame}[fragile]
  \begin{lstlisting}[language=C++]
#include <cmath>
#include <iostream>

int main () {
  int i1, i2, i3;
  std::cin >> i1 >> i2 >> i3;
  std::cout << sqrt(pow(i1, 2)+pow(i2, 2)+pow(i3, 2)) << '\n';
  std::cout << i1*i2*i3 << '\n';
  std::cout << 2*(i1*i2 + i1*i3 + i2*i3) << '\n';
  return 0;
}
// import math
// i1 = int(input())
// i2 = int(input())
// i3 = int(input())
// print(math.sqrt(i1**2, i2**2, i3**2))
// print(i1*i2*i3)
// print(2*(i1*i2 + i1*i3 + i2*i3))\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
  \begin{lstlisting}[language=C++]
#include <cmath>
#include <iostream>

int main () {
  int height, width, depth;
  std::cin >> height >> width >> depth;

  std::cout << 
    sqrt(pow(height, 2)+pow(width, 2)+pow(depth, 2)) << '\n';

  std::cout << height*width*depth << '\n';
  std::cout << 
    2*(height*width + height*depth + width*depth) << '\n';

  return 0;
}
// import math
// height = int(input())
// width = int(input())
// depth = int(input())
// print(math.sqrt(height**2, width**2, depth**2))
// print(height*width*depth)
// print(2 * (height*width + height*depth + depth*width))\end{lstlisting}
\end{frame}

\section{Functions}
\begin{frame}{Functions}
  Rules around functions
  \note{
    Functions are one of the oldest thing that we still have in early programming days.\\
  }
  \begin{itemize}[<+->]
    \item Should be small
    \note[item]<.>{
      Divide complicated logic into multiple simple parts.
    }
    \item Should do one thing
    \note[item]<.>{
      if a function is complicated, break down into multiple functions
    }
    \item One level of abstraction per funciton
    \note[item]<.>{
      We want the code to read like a top-down narrative
    }
    \note[item]<.>{
      Give that simple parts proper context
    }
    \note[item]<.>{
      use static factories instead of switch cases switch cases. switch case must be burried into one function
    }
    \item Should have descriptive names
    \note[item]<.>{
      Should be named very well, and if the name includes "and", they are probably not doing one and one thing only.
    }
    \note[item]<.>{
      Don't be afraid of long names
    }
    \note[item]<.>{
      Don't be afraid to spend time choosing a name
    }
    \item Should have minimum arguments
    \note[item]<.>{ 
      zero is the best. one is good, closely comes two.\\
      Three arguments should be avoided when possible\\
      More than three SHOULDN'T BE USED \\ 
      Output arguments SHOULD NOT BE USED \\
      because it makes the code confusing
    }
    \item Have no side effects
    \note[item]<.>{ 
      side effect: it does things that doesn't say it will do
    }
  \end{itemize}
\end{frame}

\subsection{example}
\begin{frame}[fragile]
  \begin{lstlisting}[language=C++]
#include <cmath>
#include <iostream>

double cuboid_surface(int height, int width, int depth) {
  return 2*(height*width + height*depth + width*depth);
}

double cuboid_volume(int height, int width, int depth) {
  return height * width * depth;
}

double cuboid_diagonal(int height, int width, int depth) {
  return sqrt(pow(height, 2)+pow(width, 2)+pow(depth, 2));
}

int main () {
  int height, width, depth;
  std::cin >> height >> width >> depth;
  std::cout << cuboid_diagonal(height, width, depth) << '\n';
  std::cout << cuboid_volume(height, width, depth) << '\n';
  std::cout << cuboid_surface(height, width, depth) << '\n';
  return 0;
} \end{lstlisting}

\end{frame}
\begin{frame}[fragile]
  \begin{lstlisting}[language=Python]
def cuboid_surface(height, width, depth):
  return 2 * (height*width + height*depth + depth*width)

def cuboid_volume(height, width, depth):
  return height * width * depth

def cuboid_diagonal(height, width, depth):
  return math.sqrt(height**2, width**2, depth**2)

height = int(input())
width = int(input())
depth = int(input())

print(cuboid_diagonal(height, width, depth))
print(cuboid_volume(height, width, depth))
print(cuboid_surface(height, width, depth))\end{lstlisting}

\end{frame}

\section{Objects and Data structures}
\subsection{Data structures}
\begin{frame}{Data structures}
  \note{
    makes it EASY to add new functions without changing the existing data structure \\
    makes it HARD to add new data structures because all the functions must change. \\
  }
  Simple data structures are good at modularity. They have no behavior or operation by their own.
  \begin{itemize}
    \item Only expose data, not operation
  \end{itemize}
\end{frame}
\begin{frame}[fragile]
  \begin{lstlisting}[language=C++]
#include <cmath>
#include <iostream>

class Cuboid {
public:
  int height, width, depth;
  Cuboid(int height, int width, int depth) {
    this->height = height;
    this->width = width;
    this->depth = depth;
  }
};

double cuboid_surface(Cuboid cuboid) {
  return 2*(cuboid.height*cuboid.width 
    + cuboid.height*cuboid.depth 
    + cuboid.width*cuboid.depth);
}

double cuboid_volume(Cuboid cuboid) {
  return cuboid.height * cuboid.width * cuboid.depth;
}

double cuboid_diagonal(Cuboid cuboid) {
  return sqrt(pow(cuboid.height, 2)+pow(cuboid.width, 2)+pow(cuboid.depth, 2));
}

 \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
  \begin{lstlisting}[language=C++]
int main () {
  int height, width, depth;
  std::cin >> height >> width >> depth;
  Cuboid cuboid = Cuboid(height, width, depth);
  std::cout << cuboid_diagonal(cuboid) << '\n';
  std::cout << cuboid_volume(cuboid) << '\n';
  std::cout << cuboid_surface(cuboid) << '\n';
  return 0;
} \end{lstlisting}
\end{frame}
\subsection{Objects}
\begin{frame}{Objects}
  Objects are good at data abstraction. They hide the details and only expose operation.
  \note{
    makes it EASY to add new classes without changing existing functions \\
    makes it HARD to add new functions because all the classes must change\\
  }
  \begin{itemize}[<+->]
    \item Use abstract functions. 
      \note[item]<.>{
        don't use getter setters. expose high level operations.
      }
      \note[item]<.>{
        example of bingewatcher and percentage
      }
    \item Don't expose data
      \note[item]<.>{
        again, no getter setters. protected or private.
      }
  \end{itemize}
\end{frame}
\begin{frame}[fragile]
  \begin{lstlisting}[language=C++]
#include <cmath>
#include <iostream>
class Cuboid {
private:
  int height, width, depth;
public:
  Cuboid(int height, int width, int depth) {
    this->height = height;
    this->width = width;
    this->depth = depth;
  }
  double surface() {
    return 2*(height*width + height*depth + width*depth);
  }
  double volume() {
    return height * width * depth;
  }
  double diagonal() {
    return sqrt(pow(height, 2)+pow(width, 2)+pow(depth, 2));
  }
};\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
  \begin{lstlisting}[language=C++]
int main () {
  int height, width, depth;
  std::cin >> height >> width >> depth;
  Cuboid cuboid = Cuboid(height, width, depth);
  std::cout << cuboid.diagonal() << '\n';
  std::cout << cuboid.volume() << '\n';
  std::cout << cuboid.surface() << '\n';
} \end{lstlisting}
\end{frame}
\subsection{Hybrids}
\begin{frame}{Hybrids}
  Hybrids are when you expose both data and operation. This will become a mess to deal with.\\
  DON'T USE HYBRIDS
  \note{
    makes it HARD to add new functions because all the classes must change\\
    makes it HARD to add new data structures because all the functions must change. \\
  }
\end{frame}
\section{Sources}
\begin{frame} {The end :D}
  \begin{columns}
    \column{.5\textwidth}
    Thanks for being awake! \\
    If you liked the presentation, check the \textbf{sources} of this document from link at the right.
    \column{.5\textwidth}
    \qrcode[height=60pt]{https://github.com/nimaaskarian/clean-code-presentation}
  \end{columns}
\end{frame}
\end{document}
